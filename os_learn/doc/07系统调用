# 系统调用

## 目录

- 程序调度细节
- 进程资源竞争
- 系统调用

## 系统调用

系统调用是用户进程与内核沟通的方式。可以将 CPU 从用户态转向内核态；

用中断门来实现系统调用，与 linux 兼容，使用 `0x80` 号中断函数；

其中 linux 32 位：

- eax 存储系统调用号
- ebx 存储第一个参数
- ecx 存储第二个参数
- edx 存储第三个参数
- esi 存储第四个参数
- edi 存储第五个参数
- ebp 存储第六个参数
- eax 存储返回值

系统调用的过程

```s
    mov eax, 系统调用号
    mov ebx, 第一个参数
    mov ecx, 第二个参数
    mov edx, 第三个参数
    int 0x80;
```


# 系统调用
-    int 0x80
--   中断程序响应80号中断， 系统调用处理函数根据 eax 参数，判断使用系统调用中的那个值
--   系统调用表中。找到对应的中断处理程序。
--- interrupt.c -> handler.asm -> 根据eax  (gate.c 中syscall_table 中的函数数组) -> 具体实现的函数

--- 用户系统调用 -> 库封装的系统调用函数（封装参数，确定需要调用的系统接口 eax,及参数 ebx...）-> 库函数构造完成 开始发出中断int 0x80 及内陷指令 ->interrupt.c -> handler.asm -> 根据eax  (gate.c 中syscall_table 中的函数数组) -> 具体实现的函数