# 中断函数

## 简介

- 内中断
    - 软中断：
        - 系统调用：读写文件
    - 异常：
        - 除零
        - 指令错误
        - 缺页错误
- 外中断：
    - 时钟中断
    - 键盘中断
    - 硬盘中断：
        - 同步端口IO
        - 异步端口IO
        - DMA Direct Memory Access

![](./images/interrupt_01.drawio.svg)

## 中断函数

* call / ret
    * eip
* int(interrupt) / iret (interrupt return)
    - eip
    - cs
    - eflags

## 中断向量表 实模式

中断向量就是中断函数的指针

> `0x000` ~ `0x3ff` 

4 个字节表示一个中断向量，总共有 256 个中断函数指针

段地址 << 4 + 偏移地址

* 偏移地址 (ip)
* 段地址 (cs)

    int nr; 中断函数编号 0 ~ 255

    invoke # 调用，引发，触发

## 内存分段

16bit 能访问的64K内存，

32bit 访问所有的 4G 内存，也就是可以不分段，所以分段的概念就延续了下来；

-->
# 中断描述符

## 中断向量表

所谓中断处理，归根结底就是处理器要执行一段与该中断有关的函数。处理器可以识别 256 个中断，那么理论上就需要 256 个函数。这些程序的位置并不重要，重要的是，在实模式下，处理器要求将它们的入口点集中存放到内存中从物理地址 0x000 开始，到 0x3ff 结束，共 1 KB 的空间内，这就是所谓的中断向量表(Interrupt Vector Table, IVT)，或者 **中断函数指针数组**。

中断向量的意思是中断函数的 **指向中断函数的指针**，也就是说中断向量表中并不存储具体的中断函数，而只存储中断函数的指针，意味着中断编程就是要自己写中断函数，然后将具体中断向量表中某一项指针修改成自己的中断函数指针，

在实模式下，一个函数指针总共 4B，包含两部分，前两个字节是 **段内偏移**，后两个字节是 **段地址**；

## 中断类型

但是，在 32 位保护模式下，这些就不适用了；但是中断处理的技术思想还是一样的，通过某种方式引发中断，然后调用中断处理函数；

引发中断的方式有三种:

- 外中断
- 异常
- 软中断

外中断就是由外部中断控制器通知 CPU 需要执行的，CPU 在当前指令执行完成之后，回去检测是否有中断产生，如果有，并且 `IF` 位有效，也就是允许中断，那么就会执行中断处理函数，这种方式直接的体验就是，CPU 可以在任意两个指令间插入一个中断函数调用，中断函数调用与普通函数调用稍有区别，在调用时栈中多压了一些数据，在中断返回时，会弹出；

异常和软中断统称为 内中断，也就是这个中断时 CPU 和 软件内部产生的，与外部硬件无关；

异常是 CPU 在执行过程中，执行不下去了，引发的中断调用，比如 除零异常，缺页异常，一般保护错误，有一些异常在处理后程序是可以继续执行的，比如缺页异常，而有一些异常就不行了，比如一般保护，这种情况下一般是软件访问了不该访问的内存或者寄存器，自己没有权限，于是CPU会调用一般保护异常函数，这个函数中，一般会终止该进程的执行，试图访问自己没有权限的内容，应该是危险的程序，可能是恶意程序，或者是程序有漏洞；

软中断，可以认为是应用程序和操作系统沟通的一种方式，应用程序运行在较低的特权级，一般来说没有直接访问硬件的权限，当应用程序想要访问硬件的时候，比如典型的读写文件，就需要调用系统调用，系统调用就是用软中断实现的，也就是应用程序调用软中断函数来请求操作系统，以访问硬件，访问硬件的函数是操作系统实现的，于是被认为是安全的，就这样。

## 中断描述符

在保护模式下，处理器对中断的管理是相似的，但并非使用传统的中断向量表来保存中断处理函数的地址；

中断向量 --> 中断描述符
中断向量表 --> 中断描述符表 

Interrupt Descriptor Table (IDT)

- 代码段 (cs)
- 段内偏移地址 (eip)
- 一些属性

```c++
typedef struct gate_t
{
    u16 offset0;    // 段内偏移 0 ~ 15 位
    u16 selector;   // 代码段选择子
    u8 reserved;    // 保留不用
    u8 type : 4;    // 任务门/中断门/陷阱门
    u8 segment : 1; // segment = 0 表示系统段
    u8 DPL : 2;     // 使用 int 指令访问的最低权限
    u8 present : 1; // 是否有效
    u16 offset1;    // 段内偏移 16 ~ 31 位
} _packed gate_t;
```

### type segment = 0

- 0b0101 - 任务门 (Task Gate)：很复杂，而且很低效 x64 就去掉了这种门
- 0b1110 - **中断门** (Interrupt Gate) `IF` 位自动置为 0
- 0b1111 - 陷阱门 (Trap Gate)

## 中断描述符表 Interrupt Descriptor Table (IDT)

```c++
gate_t idt[IDT_SIZE];
```

- idtr / 中断描述符表的起始位置和长度

```s
lidt [idt_ptr]; 加载 idt
sidt [idt_ptr]; 保存 idt
```

```cpp
typedef struct pointer
{
    unsigned short limit; // size - 1
    unsigned int base;
} __attribute__((packed)) pointer;
```

# 异常

- 故障
- 陷阱
- 终止

## 故障 Fault

这种错误是可以被修复的一种类型，属于最轻的一种异常；

## 陷阱 Trap

此异常通常用于调试

## 终止 Abort

是最严重的异常类型，一旦出现由于 错误无法修复，程序将无法继续运行；

## 异常列表

| 编号              | 名称           | 类型      | 助记符  | 错误码    |
| ----------------- | -------------- | --------- | ------- | --------- |
| 0 (0x0)           | 除零错误       | 故障      | #DE     | 无        |
| 1 (0x1)           | 调试           | 故障/陷阱 | #DB     | 无        |
| 2 (0x2)           | 不可屏蔽中断   | 中断      | -       | 无        |
| 3 (0x3)           | 断点           | 陷阱      | #BP     | 无        |
| 4 (0x4)           | 溢出           | 陷阱      | #OF     | 无        |
| 5 (0x5)           | 越界           | 故障      | #BR     | 无        |
| 6 (0x6)           | 指令无效       | 故障      | #UD     | 无        |
| 7 (0x7)           | 设备不可用     | 故障      | #NM     | 无        |
| 8 (0x8)           | 双重错误       | 终止      | #DF     | 有 (Zero) |
| 9 (0x9)           | 协处理器段超限 | 故障      | -       | 无        |
| 10 (0xA)          | 无效任务状态段 | 故障      | #TS     | 有        |
| 11 (0xB)          | 段无效         | 故障      | #NP     | 有        |
| 12 (0xC)          | 栈段错误       | 故障      | #SS     | 有        |
| 13 (0xD)          | 一般性保护异常 | 故障      | #GP     | 有        |
| 14 (0xE)          | 缺页错误       | 故障      | #PF     | 有        |
| 15 (0xF)          | 保留           | -         | -       | 无        |
| 16 (0x10)         | 浮点异常       | 故障      | #MF     | 无        |
| 17 (0x11)         | 对齐检测       | 故障      | #AC     | 有        |
| 18 (0x12)         | 机器检测       | 终止      | #MC     | 无        |
| 19 (0x13)         | SIMD 浮点异常  | 故障      | #XM/#XF | 无        |
| 20 (0x14)         | 虚拟化异常     | 故障      | #VE     | 无        |
| 21 (0x15)         | 控制保护异常   | 故障      | #CP     | 有        |
| 22-31 (0x16-0x1f) | 保留           | -         | -       | 无        |

说明：

0. 当进行除以零的操作时产生
1. 当进行程序单步跟踪调试时，设置了标志寄存器 eflags 的 T 标志时产生这个中断
2. 由不可屏蔽中断 NMI 产生
3. 由断点指令 int3 产生，与 debug 处理相同
4. eflags 的溢出标志 OF 引起
5. 寻址到有效地址以外时引起
6. CPU 执行时发现一个无效的指令操作码
7. 设备不存在，指协处理器，在两种情况下会产生该中断：
    1. CPU 遇到一个转意指令并且 EM 置位时，在这种情况下处理程序应该模拟导致异常的指令
    2. MP 和 TS 都在置位状态时，CPU 遇到 WAIT 或一个转移指令。在这种情况下，处理程序在必要时应该更新协处理器的状态
8. 双故障出错
9.  协处理器段超出，只有 386 会产生此异常
10. CPU 切换时发觉 TSS 无效
11. 描述符所指的段不存在
12. 堆栈段不存在或寻址堆栈段越界
13. 没有符合保护机制（特权级）的操作引起
14. 页不在内存或不存在
15. 保留
16. 协处理器发出的出错信号引起
17. 对齐检测只在 CPL 3 执行，于 486 引入
18. 与模型相关，于奔腾处理器引入
19. 与浮点操作相关，于奔腾 3 引入
20. 只在可以设置 EPT - violation 的处理器上产生
21. ret, iret 等指令可能会产生该异常


## GP(0x0D) 异常错误码

![](./images/gp_error_code.drawio.svg)

| 索引  | 长度 | 名称              | 描述           |
| ----- | ---- | ----------------- | -------------- |
| E     | 1    | 外部(External)    | 异常由外部触发 |
| TBL   | 2    | IDT/GDT/LDT Table | 见下列表       |
| INDEX | 13   | 选择子索引        |

TBL:

- 00 GDT
- 01 IDT
- 10 LDT
- 11 IDT




# 外中断原理

## 指令执行流程

![](./images/instruction_01.drawio.svg)

- 取指：将 eip 指向的指令读入处理器
- 译码：将指令的微程序写入流水线 (多级 cache)
- 执行：执行指令
- 中断：处理中断

## EFLAGS 程序状态字

![](./image/../images/eflags.drawio.svg)

- IF: Interrupt Flag 外中断允许标志，CPU 外中断的总开关

```s
sti; 设置 IF 位 (set interrupt)，允许外中断
cli; 清除 IF 位 (clear interrupt)，禁止外中断

pushf; 将 elags 压入栈中
popf; 将栈顶弹出到 eflags
```

## 80486 CPU 引脚图

![](./images/80486.jpg)

## 中断机制

PIC Programmable Interrupt Controller 可编程中断控制器

在使用 80x86 组成的 PC 机中，采用了两片 8259a 可编程中断控制芯片。每片可以管理 8 个中断源。通过多片的级联方式，能构成最多管理 64 个中断向量的系统。在 PC/AT 系列兼容机中，使用了两片 8259a 芯片，共可管理 15 个中断向量。其级连示意图下图所示。其中从芯片的 INT 引脚连接到主芯片的 IR2 引脚上。主 8259a 芯片的端口基地址是 0x20，从芯片是 0xa0；

![](./images/8259a.drawio.svg)


可屏蔽中断是通过 INTR 信号线进入 CPU，一般可独立运行的外部设备，如打印机、声卡等，其发出的中断都是可屏蔽中断，都共享这一根 INTR 信号线通知 CPU。中断控制器 8259a 就是用来作中断仲裁的；

下面是 8259A 内部结构逻辑示意图：

![](./images/8259a-block.jpg)

- INT: 8259A 选出优先级最高的中断请求后，发信号通知 CPU；
- INTA: INT Acknowledge，中断响应信号，位于 8259A 中的 INTA 接收来自 CPU 的 INTA 接口的中断响应信号；
- IMR: Interrupt Mask Register，中断屏蔽寄存器，宽度是8 位，用来屏蔽某个外设的中断；
- IRR: Interrupt Request Register，中断请求寄存器，宽度是 8 位。它的作用是接受经过 IMR 寄存器过滤后的中断信号并锁存，此寄存器中全是等待处理的中断；
- PR: Priority Resolver，优先级仲裁器，当有多个中断同时发生，或当有新的中断请求进来时，将它与当前正在处理的中断进行比较，找出优先级更高的中断；
- ISR: In-Service Register，中断服务寄存器，宽度是 8 位，当某个中断正在被处理时，保存在此寄存器中；

以上介绍的寄存器都是 8 位，这是有意这样做的，其原因是 8259A 共 8 个 IRQ 接口，可以用 8 位寄存器中的每一位代表 8259A 的每个 IRQ 接口，类似于接口的位图，这样在后续的操作中，操作寄存器中的位便表示处理来自对应的 IRQ 接口的中断信号。

---

### 中断启动流程

当某个外设发出一个中断信号时，由于主板上已经将信号通路指向了 8259A 芯片的某个 IRQ 接口，所以该中断信号最终被送入了 8259A；

8259A 首先检查 IMR 寄存器中是否已经屏蔽了来自该 IRQ 接口的中断信号。IMR 寄存器中的位，为 1，则表示中断屏蔽，为 0，则表示中断放行；

如果该 IRQ 对应的相应位己经被置 1，即表示来自该 IRQ 接口上的中断已经被屏蔽了，则将该中断信号丢弃；否则，将其送入 IRR 寄存器，将该 IRQ 接口所在 IRR 寄存器中对应的位设为 1。IRR 寄存器的作用**相当于**待处理中断队列；

在某个恰当时机，优先级仲裁器 PR 会从 IRR 寄存器中挑选一个优先级最大的中断，此处的优先级决判很简单，就是 IRQ 接口号越低，优先级越大，所以 IRQ0 优先级最大；

之后，8259A 会在控制电路中，通过 INT 接口向 CPU 发送中断信号，信号被送入了 CPU 的中断接口；

当 CPU 将当前指令执行完后，进入中断检测的阶段，于是检测到有新的中断到来了；

于是，马上通过自己的 INTA 接口向 8259A 的 INTA 接口回复一个中断响应信号，表示现在 CPU 我已准备好啦，8259A 你可以继续后面的工作了；

8259A 在收到这个信号后，立即将刚才选出来的优先级最大的中断在ISR 寄存器中对应的位设为 1，此寄存器表示当前正在处理的中断，同时要将该中断从 **待处理中断队列** 寄存器 IRR 中去掉，也就是在IRR 中将该中断对应的位设为 0；

之后，CPU 将再次发送 INTA 信号给 8259A，这一次是想获取中断对应的中断向量号；

用起始中断向量号 + IRQ 接口号便是该设备的中断向量号，由此可见，外部设备虽然会发中断信号，但它并不知道还有中断向量号这回事，不知道自己会被中断代理 (如8259A) 分配一个这样的整数。

随后， 8259A 将此中断向量号通过系统数据总线发送给 CPU，CPU 从数据总线上拿到该中断向量号后，用它做中断向量表或中断描述符表中的索引，找到相应的中断处理程序井去执行；

----

### 中断处理流程

如果 8259A 的 EOI 通知 (End Of Interrupt) 被设置为非自动模式 (手工模式)，中断处理程序结束前必须向 8259A 发送 EOI；

8259A 在收到 EOI 后，将当前正处理的中断在 ISR 寄存器中对应的位设为 0；

如果 EOI 通知 被设置为自动模式，在刚才 8259A 接收到第二个INTA 信号后，也就是 CPU 向 8259A 要中断向量号的那个 INTA, 8259A 会自动将此中断在 ISR 寄存器中对应的位设为 0；

并不是进入了 ISR 后的中断就可以被 CPU 处理了，它还是有可能被后者换下来的。

比如，在 8259A 发送中断向量号给 CPU 之前，这时候又来了新的中断，如果它的来源 IRQ 接口号比 ISR 中的低，也就是优先级更高，原来 ISR 中准备上 CPU 处理的旧中断，其对应的位就得清 0，同时将它所在的 IRR 中的相应位恢复为 1，随后在 ISR 中将此优先级更高的新中断对应的位设为 1，然后将此新中断的中断向量号发给 CPU。如果新来的中断优先级较低，依然会被放进 IRR 寄存器中等待处理；

## 目录

- GP 异常码的解释
- 内联汇编的解释
- 80486 的解释
- 中断向量的解释
- 外中断细节调试
    - IF 位
    - 0x206;
    - 0b_0010_0000_0110;
- 中断控制器编程

```c++
void pic_init();
void send_eoi(int vector);
```

## EFLAGS 程序状态字

![](./image/../images/eflags.drawio.svg)

## PC 中断默认级联图

![](./images/8259a.drawio.svg)

## 中断控制器编程

在 8259A 内部有两组寄存器：

- 初始化命令寄存器组，保存初始化命令字 (Initialization Command Words, ICW), ICW 共 4 个， ICW1 ~ ICW4；
- 操作命令寄存器组，保存操作命令字 (Operation Command Word, OCW), OCW 共 3 个， OCW1 ~ OCW3；

ICW 做初始化，用来确定是否需要级联，设置起始中断向量号，设置中断结束模式。其编程就是往 8259A 的端口发送一系列 ICW。由于从一开始就要决定 8259A 的工作状态，所以要一次性写入很多设置，某些设置之间是具有关联、依赖性的，也许后面的某个设置会依赖前面某个 ICW 写入的设置，所以这部分要求严格的顺序，必须依次写入 ICW1、ICW2、ICW3、ICW4；

OCW 来操作控制 8259A，前面所说的中断屏蔽和中断结束，就是通过往 8259A 端口发送 OCW 实现的。OCW 的发送顺序不固定，3 个之中先发送哪个都可以。

---

### ICW1 连接 / 触发方式

ICW1 用来初始化 8259A 的 **连接方式** 和中断信号的 **触发方式**；

- 连接方式 是指用单片工作，还是用多片级联工作；
- 触发方式 是指中断请求信号是电平触发，还是边沿触发；

如下表所示，共一个字节；

| 7   | 6   | 5   | 4   | 3    | 2   | 1     | 0   |
| --- | --- | --- | --- | ---- | --- | ----- | --- |
| 0   | 0   | 0   | 1   | LTIM | ADI | SINGL | IC4 |

ICW1 需要写入到主片的 `0x20` 端口和从片的 `0xA0` 端口；

IC4 表示是否要写入 ICW4，这表示，并不是所有的 ICW 初始化控制字都需要用到；IC4 为 1 时表示需要在后面写入 ICW4 ，为 0 ICW1 则不需要。注意，x86 系统 IC4 必须为1

SNGL 表示 single，若 SNGL 为 1 ，表示单片，若 SNGL 为 0，表示级联(Cascade)。若在级联模式下，这要涉及到主片和从片用哪个 sIRQ 接口互相连接的问题，所以当 SNGL 为 0 时，主片和从片也是需要 ICW3 的。

ADI 表示 Call Address Interval，用来设置 8085 的调用时间间隔， x86 不需要设置。

LTIM 表示 Level/Edge Triggered Mode，用来设置中断检测方式，LTIM 为 0 表示边沿触发，LTIM 为 1 表示电平触发；

第 4 位的 1 是固定的，这是 ICW1 的标记；

第 5 ~ 7 位专用于 8085 处理器，x86 不需要，直接置为 0 即可；

---

### ICW2 向量号

ICW2 用来设置 **起始中断向量号**，一般为 `0x20`，如下表所示，共一个字节；

| 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| T7  | T6  | T5  | T4  | T3  | ID2 | ID1 | ID0 |

由于每个 8259A 芯片上的 IRQ 接口是顺序排列的，所以咱们这里的设置就是指定 IRQ0 映射到的中断向量号，其他 IRQ 接口对应的中断向量号会顺着自动排列下去。

ICW2 需要写入到主片的 `0x21` 端口和从片的 `0xA1`；

由于咱们只需要设置 IRQ0 的中断向量号， IRQ1~IRQ7 的中断向量号是 IRQ0 的顺延，所以，只需填写高 5 位 T3~T7，ID0~ID2 这低 3 位不用填。

由于只填写高 5 位，所以任意数字都是 8 的倍数，这个数字表示的便是设定的起始中断向量号。

这是有意设计的，低 3 位能表示 8 个中断向量号，这由 8259A 根据 8 个 IRQ 接口的排列位次自行导入，IRQ0 的值是 000, IRQ1 的值是001, IRQ2 的值便是 010 ... 以此类推，这样高 5 位加低 3 位，便表示了任意一个 IRQ 接口实际分配的中断向量号。

### ICW3 级联方式

ICW3 仅在 **级联的方式** 下才需要 (如果 ICW1 中的 SNGL 为 0)，用来设置主片和从片用哪个 IRQ 接口互连。

由于主片和从片的级联方式不一样，对于这个 ICW3，主片和从片都有自己不同的结构。

对于主片，ICW3 中置 1 的那一位对应的 IRQ 接口用于连接从片，若为 0 则表示接外部设备。比如，若主片 IRQ2 和 IRQ5 接有从片，则主片的 ICW3 为 00100100。

主片如下表所示，共一个字节；

| 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| S7  | S6  | S5  | S4  | S3  | S2  | S1  | S0  |

对于从片，要设置与主片 8259A 的连接方式，不需要指定用自己的哪个 IRQ 接口与主片连接，从片上专门用于级联主片的接口并不是 IRQ。

从片如下表所示，共一个字节；

| 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | ID2 | ID1 | ID0 |


如果从片用 IRQ 接口连接主片，若主片只级联一个从片，在从片上指定的 IRQ 接口便默认与主片上做级联的那个 IRQ 接口匹配了。但如果主片级联多个从片时，在从片上还要设置自己用于连接主片的 IRQ 接口与主片上连接从片的哪个 IRQ 接口（有多个）对接，这反而更麻烦。所以，设置从片连接主片的方法是只需要在从片上指定主片用于连接自己的那个 IRQ 接口就行了。

在中断响应时，主片会发送与从片做级联的 IRQ 接口号，所有从片用自己的 ICW3 的低 3 位和它对比，若一致则认为是发给自己的。

比如主片用 IRQ2 接口连接从片 A，用 IRQ5 接口连接从片 B；从片 A 的 ICW3 的值应该设为 0b00000010，就是十进制数 2，从片 B 的 ICW3 的值应该设为 0b00000101，就是十进制数 5；所以，从片 ICW3 中的低 3 位 ID0 ~ ID2 就够了，高 5 位不需要，为 0 即可。

---

### ICW4 工作模式

ICW4 用于设置 8259A 的 **工作模式**，当 ICW1 中的 IC4 为 1 时才需要 ICW4；

如下表所示，共一个字节；

| 7   | 6   | 5   | 4    | 3   | 2   | 1    | 0   |
| --- | --- | --- | ---- | --- | --- | ---- | --- |
| 0   | 0   | 0   | SFNM | BUF | M/S | AEOI | μPM |

ICW4 需要写入主片的 `0x21` 及从片的 `0xA1` 端口；

第 7~5 位未定义，直接置为 0 即可；

SFNM 表示特殊全嵌套模式(Special Fully Nested Mode)，若 SFNM 为 0，则表示全嵌套模式，若 SFNM 为 1，则表示特殊全嵌套模式。

BUF 表示本 8259A 芯片是否工作在缓冲模式。BUF 为 0 ，则工作非缓冲模式，BUF 为 1 ，则工作在缓冲模式。

M/S 用于指定主片和从片；当多个 8259A 级联时，如果工作在缓冲模式下(BUF = 1)，若 M/S 为 1 ，则表示则表示是主片，若 M/S 为0，则表示是从片。若工作在非缓冲模式下(BUF = 0)， M/S 无效。

AEOI 表示自动结束中断 (Auto End Of Interrupt)，8259A 在收到中断结束信号时才能继续处理下一个中断，此项用来设置是否要让 8259A 自动把中断结束。

- 若 AEOI 为 0 ，则表示非自动，即手动结束中断，可以在中断处理程序中手动向 8259A 的主、从片发送 EOI 信号。这种 **操作** 类命令，通过下面要介绍的 OCW 进行；
- 若 AEOI 为 1 ，则表示自动结束中断；

μPM 表示微处理器类型 (microprocessor)，此项是为了兼容老处理器。若 μPM 为 0，则表示 8080 或 8085 处理器，若 μPM 为1 ，则表示 x86 处理器。

---

### OCW1 屏蔽字

OCW1 用来屏蔽连接在 8259A 上的外部设备的中断信号，如下表所示，共一个字节；

| 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| M7  | M6  | M5  | M4  | M3  | M2  | M1  | M0  |

实际上就是把 OCW1 写入了即 IMR 寄存器。这里的屏蔽是说是否把来自外部设备的中断信号转发给 CPU。由于外部设备的中断都是可屏蔽中断，所以最终还是要受标志寄存器 eflags 中的 IF 位的管束，若 IF 为 0，可屏蔽中断全部被屏蔽，也就是说，在 IF 为 0 的情况下，即使 8259A 把外部设备的中断向量号发过来，CPU 也置之不理。

OCW1 要写入主片的 `0x21` 或从片的 `0xA1` 端口；

---

### OCW2 结束方式

OCW2 用来设置中断结束方式和优先级模式，如下表所示，共一个字节；

| 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| R   | SL  | EOI | 0   | 0   | L2  | L1  | L0  |

OCW2 要写入主片的 `0x20` 或从片的 `0xA0` 端口；

高 3 位 R、SL、EOI 可以定义多种 **中断结束方式** 和 **优先级循环方式**。

R (Rotation)，表示是否按照循环方式设置中断优先级。R 为 1 表示优先级自动循环， R 为 0 表示不自动循环，采用固定优先级方式。

- 如果 R 为 0，表示固定优先级方式，即 IRQ 接口号越低，优先级越高。
- 如果 R 为 1，表明用循环优先级方式，这样优先级会在 0~7 内循环，具体解释见下文；

SL (Specific Level)，表示是否指定优先等级。等级是用低 3 位来指定的。此处的 SL 只是开启低 3 位的开关，所以 SL 也表示低3 位的 L2~L0 是否有效。SL 为 1 表示有效，SL 为 0 表示无效。

EOI (End Of Interrupt)，为中断结束命令位。令 EOI 为 1，则会令 ISR 寄存器中的相应位清 0，也就是将当前处理的中断清掉，表示处理结束。向 8259A 主动发送 EOI 是手工结束中断的做法，所以，使用此命令有个前提，就是 ICW4 中的 AEOI 位为 0，非自动结束中断时才用。

在手动结束中断 (AEOI 位为 0) 的情况下，如果中断来自主片，只需要向主片发送 EOI 就行了，如果中断来自从片，除了向从片发送 EOI 以外，还要再向主片发送 EOI。

第 4~3 位的 00 是 OCW2 的标识。

L2~L0 用来确定优先级的编码，这里分两种：

- 用于 EOI 时，表示被中断的优先级别；
- 用于优先级循环时，指定起始最低的优先级别；

---

优先级循环方式的解释：

首先 R 必须是 1；

如果 SL 为 0，初始的优先级次序为：

IR0 > IR1 > IR2 > IR3 > IR4 > IR5 > IR6 > IR7；

当某级别的中断被处理完成后，它的优先级别将变成最低，将最高优先级传给之前较之低一级别的中断请求，其他依次类推。所以，可循环方式多用于各中断源优先级相同的情况，优先级通过这种循环可以实现轮询处理。该循环可总结为如果循环优先级 IR(i) 优先级最低，则 IR(i + 1) 优先级最高；

如果 SL 为 1，若想指定 IR5 为最低的优先级，需要将 L2~L0 置为 101。这样，新的初始优先级循环是：

IR6 > IR7 > IR0 > IR1 > IR2 > IR3 > IR4 > IR5；

---

### OCW3 特殊 / 查询方式

OCW3 用来设定特殊屏蔽方式及查询方式，如下表所示，共一个字节；

| 7   | 6    | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | ---- | --- | --- | --- | --- | --- | --- |
| /   | ESMM | SMM | 0   | 1   | P   | RR  | RIS |

OCW2 要写入主片的 `0x20` 或从片的 `0xA0` 端口；

第 7 位未用到；

ESMM (Enable Special Mask Mode) 和 SMM (Special Mask Mode) 是组合在一起用的，用来启用或禁用特殊屏蔽模式。

ESMM 是特殊屏蔽模式允许位，是个开关。SMM 是特殊屏蔽模式位。只有在启用特殊屏蔽模式时，特殊屏蔽模式才有效。也就是若 ESMM 为 0，则 SMM 无效。若 ESMM 为 1，SMM 为 0，表示未工作在特殊屏蔽模式。若 ESMM 和 SMM 都为 1，这才正式工作在特殊屏蔽模式下。

第 4~3 位的 01 是 OCW3 的标识，8259A 通过这两位判断是哪个控制字。

P(Poll command)，查询命令，当 P 为 1 时，设置 8259A 为中断查询方式，这样就可以通过读取寄存器，如 IRS，来查看当前的中断处理情况。

RR，Read Register，读取寄存器命令。它和 RIS 位是配合在一起使用的。当 RR 为 1 时才可以读取寄存器。

RIS，Read Interrupt register Select，读取中断寄存器选择位，顾名思义，就是用此位选择待读取的寄存器。有点类似显卡寄存器中的索引的意思。若 RIS 为 1，表示选择 ISR 寄存器，若 RIS 为 0，表示选择 IRR 寄存器。这两个寄存器能否读取，前提是 RR 的值为 1。

---

## 其他的问题

8259A 就 2 个端口地址，它是如何识别 4 个 ICW 和 3 个 OCW 的？

ICW1，OCW2，OCW3 是用偶地址端口主片的 `0x20` 或从片的 `0xA0` 写入。

ICW2~ICW4 和 OCW1 是用奇地址端口主片的 `0x21` 或从片的 `0xA1` 写入。

以上 4 个 ICW 要保证一定的次序写入，8259A 就知道写入端口的数据是什么了。

---

OCW 的写入与顺序无关，并且 ICW1 和 OCW2, OCW3 的写入端口是一致的，8259A 怎样来辨识它们呢?

其实就是通过各控制字中的第 4~3 标识位，通过这两位的组合来唯一确定某个控制字，如下表；

| 控制字 | 第 4 位 | 第 3 位 |
| ------ | ------- | ------- |
| ICW1   | 1       | /       |
| OCW2   | 0       | 0       |
| OCW3   | 0       | 1       |

---

OCW1 是怎样确定的呢？

OCW 是在初始化之后才有效的，所以在初始化之后写入奇地址端口的数据便被认为是 OCW1。

---

### 编程步骤

- 无论 8259A 是否级联，ICW1 和 ICW2 是必须要有的，并且要顺序写入；

- 只有当 ICW1 中的 SNGL 位为 0 时，这表示级联，级联就需要设置主片和从片，这才需要在主片和从片中各写入 ICW3；注意， ICW3 的格式在主片和从片中是不同的；

- 只能在 ICW1 中的 IC4 为 1 时，才需要写入 ICW4。不过，x86 系统 IC4 必须为1；

- ICW 写完之后，才可以多 OCW 进行操作；

---

## 关键词

- 全嵌套模式
- Call Address Interval
- 缓冲模式
- 特殊屏蔽模式
- 中断查询方式

## 可能存在的问题

1. IRQ 9 为什么是 重定向的 IRQ 2？<sup><small>[[2]](#irq_9)</small></sup>

早期的 IBM PC/XT 只有一个 8259A，这样就只能处理 8 种 IRQ。但很快就发现这根本不能满足需求。所以到了IBM PC/AT，又以级连的方式增加了一个 8259A，这样就可以多处理 7 种 IRQ。原来的 8259A 被称作 Master PIC，新增的被称作 Slave PIC。但由于 CPU 只有 1 根中断线，Slave PIC 不得不级连在 Master PIC 上，占用了 IRQ2；

那么在 IBM PC/XT 上使用 IRQ2 的设备将无法再使用它；但新的系统又必须和原有系统保持兼容，怎么办？ 

由于新增加的 Slave PIC 在原有系统中不存在，所以，设计者从 Slave PIC 的 IRQ 中挑出 IRQ9，要求软件设计者将原来的 IRQ2 重定向到 IRQ9 上，也就是说 IRQ9 的中断服务程序需要去调用 IRQ2 的中断服务程序。这样，将原来接在 IRQ2 上的设备现在接在 IRQ9 上，在软件上只需要增加 IRQ9 的中断服务程序，由它调用 IRQ2 的中断服务程序，就可以和原有系统保持兼容。而在当时，增加的 IRQ9 中断服务程序是由 PC 开发商开发的 BIOS 提供的，不需要用户进行另外设置。所以就从根本上保证了兼容。

---

2. **边沿触发** 还是 **电平触发**？<sup><small>[[4]](#triggered)</small></sup>

ISA 总线不支持电平触发的中断，电平触发中断模式可能在 ISA 设备上无法使用，这意味着 PC/XT, PC/AT 以及兼容系统的 8259 **必须编程为边沿触发模式**。

一般来说电平触发要比边沿触发快，因为边沿触发依赖于时钟信号的电平变化；

---


# 中断上下文

## 目录

- 中断上下文
- 异常信息演示

## 中断上下文


# 计数器和时钟

## 目录

- bug: 显卡驱动滚屏
- bug: interrupt 0x20
- 计数器：
- 时钟
- 时间片：两个时钟中断之间的时间间隔

----

常用的可编程定时计数器 (Programmable Interval Timer PIT) 有 Intel 8253/8254，其中 8254 可以称为 8253 的增强版。

在 8253 内部有 3 个独立的计数器，分别是计数器 0 ~ 2，端口号分别为 0x40 ~ 0x42；每个计数器完全相同，都是 16 位大小，相互独立，互不干涉。

8253 计数器是个减法计数器，从初值寄存器中得到初值，然后载入计数器中，然后随着时钟变化递减。计数器初值寄存器，计数器执行寄存器，和输出锁存器都是 16 位的寄存器，高八位和低八位可以单独访问。

## 计数器

三个计数器有自己各自的用途：

- 计数器 0，端口号 0x40，用于产生时钟信号，它采用工作方式 3；
- 计数器 1，端口号 0x41，用于 DRAM 的定时刷新控制；
- 计数器 2，端口号 0x42，用于内部扬声器发出不同音调的声音，原理是给扬声器输送某频率的方波；


计数器 0 用于产生时钟中断，就是连接在 IRQ0 引脚上的时钟，也就是控制计数器 0 可以控制时钟发生的频率，以改变时间片的间隔；

## 8253 控制字

控制字寄存器，端口号 0x43，是 8 位寄存器，控制字寄存器也成为模式控制寄存器，用于指定计数器的 工作方式、读写格式 及 数制。

控制字结构：

| 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| SC1 | SC0 | RL1 | RL0 | M2  | M1  | M0  | BCD |


- SC(Select Counter) 0 ~ 1：计数器选择位
    - 00 计数器 0
    - 01 计数器 1
    - 10 计数器 2
    - 11 无效
- RL(Read Load) 0 ~ 1：读写操作位
    - 00 锁存数据，供 CPU 读
    - 01 只读写低字节
    - 10 只读写高字节
    - 11 先读写低字节，后读写高字节
- M (Mode) 0 ~ 2：模式选择
    - 000：模式 0
    - 001：模式 1
    - x10：模式 2
    - x11：模式 3
    - 100：模式 4
    - 101：模式 5
- BCD：(Binary Coded Decimal) 码
    - 0 表示二进制计数器
    - 1 二进制编码的十进制计数器

## 模式

- 模式 0：计数结束时中断
- 模式 1：硬件可重触发单稳方式
- 模式 2：比率发生器，用于分频
- 模式 3：方波发生器
- 模式 4：软件触发选通
- 模式 5：硬件触发选通

模式时序图

![](./images/intel_8253_mode.jpg)

## 振荡器

振荡器的频率大概是 1193182 Hz，假设希望中断发生的频率为 100Hz，那么计数器初值寄存器的值为：

$$V = {1193182 \over 100} = 11931$$

## 其他的问题

- 为什么 振荡器 的频率是 1193182 Hz？

最初的 PC 机，使用一个基础振荡器来生成频率，14.31818 MHz，因为这个频率常用于电视线路，这个基础频率除以 3 就得到了频率 4.77272666 MHz 用于 CPU；除以 4 得到频率 3.579545 MHz 用于 CGA 显卡控制器。从逻辑上将前两个频率求最大公约数，就得到了频率 1.1931816666 MHz，这个方案极大的节约了成本，因为 14.31818 MHz 的振荡器可以大量的生产，所以就更便宜。



# 流程


### 构造中断处理函数
### 创建中断描述符表
### 安装到IDTR 寄存器。

### log
- 构造中断描述符。主要是构造offset 的地址。指向的处理的中断函数。
-- 中断入口在汇编中构造。
-- 处理的逻辑在c代码中完成的
--- 每个中断入口，都对应了一个中断处理函数。


### 问题。
- 为何不把中断函数定义到c语言中？
-- 实际上要执行另一段和源程序无关的代码，为了不影响到原来的程序，使用汇编能更好的保存中断的上下文，以便中断执行完成之后，返回到原代码继续执行。


